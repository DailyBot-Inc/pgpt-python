# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import json

from ....core.api_error import ApiError
from ....core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ....core.jsonable_encoder import jsonable_encoder
from ....errors.unprocessable_entity_error import UnprocessableEntityError
from ....types.http_validation_error import HttpValidationError
from ....types.open_ai_completion import OpenAiCompletion
from ....types.context_filter import ContextFilter
from ....types.summarize_response import SummarizeResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class SummarizeClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def summarize(
        self,
        *,
        text: typing.Optional[str] = OMIT,
        use_context: typing.Optional[bool] = OMIT,
        context_filter: typing.Optional[ContextFilter] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        instructions: typing.Optional[str] = OMIT,
    ) -> SummarizeResponse:
        """
        Get a summary based on the input text or ingested data.

        The summary will take all input data (text and context) into a SummaryIndex.
        This will allow you to easily consume the summary in your application.

        Instructions represent extra information that 
        can be used to generate the summary (e.g. which language to use, output format, etc).

        If you provide a `context_filter`, the summary will be based on the provided context.
        If you provide a `system_prompt`, the summary will be based on the provided system prompt.

        """
        _request: typing.Dict[str, typing.Any] = {}
        if text is not OMIT:
            _request["text"] = text
        if use_context is not OMIT:
            _request["use_context"] = use_context
        if context_filter is not OMIT:
            _request["context_filter"] = context_filter
        if system_prompt is not OMIT:
            _request["prompt"] = system_prompt
        if instructions is not OMIT:
            _request["instructions"] = instructions
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/summarize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SummarizeResponse, _response.json())
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json())) # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
    
    def summarize_stream(
        self,
        *,
        text: typing.Optional[str] = OMIT,
        use_context: typing.Optional[bool] = OMIT,
        context_filter: typing.Optional[ContextFilter] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        instructions: typing.Optional[str] = OMIT,   
    ) -> typing.Iterator[OpenAiCompletion]:
        """
        Get a summary based on the input text or ingested data in a streaming fashion.

        The summary will take all input data (text and context) into a SummaryIndex.
        This will allow you to easily consume the summary in your application.

        Instructions represent extra information that 
        can be used to generate the summary (e.g. which language to use, output format, etc).

        If you provide a `context_filter`, the summary will be based on the provided context.
        If you provide a `system_prompt`, the summary will be based on the provided system prompt.

        """
        _request: typing.Dict[str, typing.Any] = { "stream": True }
        if text is not OMIT:
            _request["text"] = text
        if use_context is not OMIT:
            _request["use_context"] = use_context
        if context_filter is not OMIT:
            _request["context_filter"] = context_filter
        if system_prompt is not OMIT:
            _request["prompt"] = system_prompt
        if instructions is not OMIT:
            _request["instructions"] = instructions
        
        with self._client_wrapper.httpx_client.stream(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/summarize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _text in _response.iter_lines():
                    if len(_text) == 0:
                        continue
                    # if text contains "[DONE]" at any point, finish
                    if "[DONE]" in _text:
                        return
                    # Remove the 'data:' prefix
                    _text = _text[5:]
                    yield pydantic.parse_obj_as(OpenAiCompletion, json.loads(_text))  # type: ignore
                return
            _response.read()
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    pydantic.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
                )
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)
        
    
class AsyncSummarizeClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def summarize(
        self,
        *,
        text: typing.Optional[str] = OMIT,
        use_context: typing.Optional[bool] = OMIT,
        context_filter: typing.Optional[ContextFilter] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        instructions: typing.Optional[str] = OMIT,
    ) -> SummarizeResponse:
        """
        Get a summary based on the input text or ingested data.

        The summary will take all input data (text and context) into a SummaryIndex.
        This will allow you to easily consume the summary in your application.

        Instructions represent extra information that 
        can be used to generate the summary (e.g. which language to use, output format, etc).

        If you provide a `context_filter`, the summary will be based on the provided context.
        If you provide a `system_prompt`, the summary will be based on the provided system prompt.

        """
        _request: typing.Dict[str, typing.Any] = {}
        if text is not OMIT:
            _request["text"] = text
        if use_context is not OMIT:
            _request["use_context"] = use_context
        if context_filter is not OMIT:
            _request["context_filter"] = context_filter
        if system_prompt is not OMIT:
            _request["prompt"] = system_prompt
        if instructions is not OMIT:
            _request["instructions"] = instructions
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/summarize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SummarizeResponse, _response.json())
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json())) # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
    
    async def summarize_stream(
        self,
        *,
        text: typing.Optional[str] = OMIT,
        use_context: typing.Optional[bool] = OMIT,
        context_filter: typing.Optional[ContextFilter] = OMIT,
        system_prompt: typing.Optional[str] = OMIT,
        instructions: typing.Optional[str] = OMIT,
    ) -> typing.AsyncIterator[OpenAiCompletion]:
        """
        Get a summary based on the input text or ingested data in a streaming fashion.

        The summary will take all input data (text and context) into a SummaryIndex.
        This will allow you to easily consume the summary in your application.

        Instructions represent extra information that 
        can be used to generate the summary (e.g. which language to use, output format, etc).

        If you provide a `context_filter`, the summary will be based on the provided context.
        If you provide a `system_prompt`, the summary will be based on the provided system prompt.

        """
        _request: typing.Dict[str, typing.Any] = { "stream": True }
        if text is not OMIT:
            _request["text"] = text
        if use_context is not OMIT:
            _request["use_context"] = use_context
        if context_filter is not OMIT:
            _request["context_filter"] = context_filter
        if system_prompt is not OMIT:
            _request["prompt"] = system_prompt
        if instructions is not OMIT:
            _request["instructions"] = instructions
        
        async with self._client_wrapper.httpx_client.stream(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/summarize"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _text in _response.aiter_lines():
                    if len(_text) == 0:
                        continue
                    # if text contains "[DONE]" at any point, finish
                    if "[DONE]" in _text:
                        return
                    # Remove the 'data:' prefix
                    _text = _text[5:]
                    yield pydantic.parse_obj_as(OpenAiCompletion, json.loads(_text))
                return
            await _response.aread()